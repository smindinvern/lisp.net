(defun car (xs)
  (let (((head . tail) xs))
    head
    )
  )
(defun cdr (xs)
  (let (((head . tail) xs))
    tail
    )
  )
(defun fib (m n l i)
  (if (= i 0)
      l
    (fib n (+ m n) (n . l) (- i 1))
    )
  )

(defun print-results (expected computed)
  (println "expected:")
  (println expected)
  (println "computed:")
  (println computed)
  (let ((pass (= expected computed)))
    (println (if pass "PASS" "FAIL"))
    pass
    )
  )

; Test recursion.
(defun test1 ()
  (println "test1")
  (let ((fibs (fib 1 1 '() 20))
	(correct '(10946 6765 4181 2584 1597 987 610 377 233 144 89 55 34 21 13 8 5 3 2 1)))
    (print-results correct ((car fibs) . (cdr fibs)))
    )
  )

; Test pattern matching and recursion.
(defun rev-tail (xs rest)
  (case xs
	(
	 (
	  (x1 x2)
	  (x2 . (x1 . rest))
	  )
	 (
	  (head . tail)
	  (rev-tail tail (head . rest))
	  )
	 )
	)
  )
(defun rev (xs) (rev-tail xs '()))
(defun test2 ()
  (println "test2")
  (let ((list '(1 2 3 4 5 6 7 8 9))
	(correct '(9 8 7 6 5 4 3 2 1)))
    (print-results correct (rev list))
    )
  )

(defun sumClosure (x y)
  (lambda ()
    (+ x y)
    )
  )

; Test that lambdas capture values.
(defun test3 ()
  (println "test3")
  (let (
	(closure1 (sumClosure 2 2))
	(closure2 (sumClosure 4 4))
	)
    (println (+ (closure1) (closure2)))
    (print-results 12 (+ (closure1) (closure2)))
    )
  )

; Test map function.
(defun test4 ()
  (println "test4")
  (let ((f (lambda (x) (+ x 1))))
    (print-results '(2 3 4 5 6) (map f '(1 2 3 4 5)))
    )
  )

(define-syntax macro
  (syntax-rules ()
                ((macro x f)
                 (let ((y 4))
                   (let ((z (f (+ y x))))
		     z)
		   )
		 )
		)
  )
; Test that macros are hygienic.
(defun test5 ()
  (println "test5")
  (let ((x 12)
	(y 2))
    (let ((f (lambda (y) (+ x y))))
      (let ((correct 18)
	    (computed (macro y f)))
	(print-results correct computed))
      )
    )
  )
;; TODO: Naming the following as `macro' redefines the above `macro' and
;; causes this code to be invoked in `test5' above.
(define-syntax macro2
  (syntax-rules ()
		((macro2 (((z ...) ...) ((x ...) y) ...))
		 '((x y z ...) ... ...)
		 )
		)
  )
(defun test6 ()
  (println "test6")
  (let ((m (macro2 (((g h) (i j)) ((a b) c) ((d e) f))))
	(correct '((a c g h) (b f i j) (d c g h) (e f i j))))
    (print-results correct m)
    )
  )

(define-syntax macro3
  (syntax-rules ()
                ((macro3 ((a b ...) ...))
                 '((a b) ... ...)
		 )
		)
  )
(defun test7 ()
  (println "test7")
  (let ((m (macro3 ((a b c) (d e f))))
	(correct '((a b) (d c) (a e) (d f))))
    (print-results correct m)
    )
  )

(define-syntax macro4
  (syntax-rules ()
                ((macro4 ((a b ...) ...))
                 '((a ... b) ... ...)
		 )
		)
  )
(defun test8 ()
  (println "test8")
  (let ((m (macro4 ((a b c) (d e f) (g h i) (j k l))))
	(correct '((a d g j b) (a d g j c) (a d g j e) (a d g j f) (a d g j h) (a d g j i) (a d g j k) (a d g j l))))
    (print-results correct m)
    )
  )

(define-syntax macro5
  (syntax-rules ()
                ((macro5 (((z ...) ...) ((x ...) y) ...))
                 '((x y z) ... ...)
		 )
		)
  )
(defun test9 ()
  (println "test9")
  (let ((m (macro5 (((g h) (i j)) ((a b) c) ((d e) f))))
	(correct '((a c g) (b f h) (d c i) (e f j))))
    (print-results correct m)
    )
  )

(define-syntax macro6
  (syntax-rules ()
                ((macro6 ((a b ...) ...))
                 '((a ... a b) ... ...)
		 )
		)
  )
(defun test10 ()
  (println "test10")
  (let ((m (macro6 ((a b c) (d e f))))
	(correct '((a d a b) (a d d c) (a d a e) (a d d f))))
    (print-results correct m)
    )
  )

(define-syntax macro7
  (syntax-rules ()
                ((macro7 ((a b c ...) ...))
		 '((let ((a b)) c ...) ...)
		 )
		)
  )
(defun test11 ()
  (println "test11")
  (let ((m (macro7 ((a b c d) (d c b a))))
	(correct '((let ((a b)) c d) (let ((d c)) b a))))
    (print-results correct m)
    )
  )

(defun f (x y)
  (let ((g (lambda (z)
	     (f (- x 1) z)
	     )
	   )
	)
    (if (= x 0)
	y
      (g (+ y 1))
      )
    )
  )
(defun test12 ()
  (println "test12")
  (print-results 6 (f 2 4))
  )

(define-syntax and
  (syntax-rules ()
		((and x y)
		 (if x y nil)
		 )
		((and x y ...)
		 (if x (and y ...) nil)
		 )
		)
  )

(defun test13 ()
  (println "test13")
  (let ((n 13)
	(x 0))
    (let ((f (lambda (x)
	       (lambda (y)
		 (x . (y . (n . '())))
		 )
	       )
	     )
	  )
      (let ((g (f x))
	    (h (f n))
	    )
	(and
	 (print-results '(0 1 13) (g 1))
	 (print-results '(13 2 13) (h 2))
	 t
	 )
	)
      )
    )
  )

(defun forall (f xs)
  (case xs
	(
	 ((x . ()) (f x))
	 (_ (if (f (car xs)) (forall f (cdr xs))))
	 )
	)
  )

(defun apply (f) (f))

(defun main ()
  (forall apply '(test1 test2 test3 test4 test5 test6 test7 test8 test9 test10 test11 test12 test13))
  )

